
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module space_invaders(

	//////////// CLOCK //////////
	input clk,

	//////////// LED //////////
	output [9:0] LEDR,

	//////////// VGA //////////
	output VGA_hSync,
	output VGA_vSync, 
	output [3:0] Red, Green, Blue,

	//////////// Keyboard //////////
	input kData, 
	input kClock 
);
	//vga
	reg [9:0] counter_x = 0;  // horizontal counter
	reg [9:0] counter_y = 0;  // vertical counter
	reg [3:0] r_red = 0;
	reg [3:0] r_blue = 0;
	reg [3:0] r_green = 0;
	
	
		
	//clock
	wire clk25MHz;
	wire clk_move;

	//logic
	integer size_x = 20;
	integer size_y = 30;
	integer position_x = (640/2) + 144;
	integer position_y = 450;
	wire  [2:0] direction_x;
	integer direction_y = 0;
	
	// enemy
	integer enemy_x_pos = 400; 
	integer enemy_y_pos = 40;
	integer enemy_size = 20;
	reg enemy_direction = 0;
	
	
	
	move_clk update_clk(clk, clk_move);
	vga_clk vga_reduce(clk, clk25MHz);
	keyboard move(kData, kClock, direction_x, LEDR);
	
	
	
	
	// counter and sync generation
	always @(posedge clk25MHz)  // horizontal counter
	begin 
		if (counter_x < 799)
			counter_x <= counter_x + 1;  // horizontal counter (including off-screen horizontal 160 pixels) total of 800 pixels 
		else
			counter_x <= 0;              
	end  
	
	always @ (posedge clk25MHz)  // vertical counter
	begin 
		if (counter_x == 799)  // only counts up 1 count after horizontal finishes 800 counts
			begin
				if (counter_y < 525)  // vertical counter (including off-screen vertical 45 pixels) total of 525 pixels
					counter_y <= counter_y + 1;
				else
					counter_y <= 0;              
			end  
	end  

   // hsync and vsync output assignments
	assign VGA_hSync = (counter_x >= 0 && counter_x < 96) ? 1:0;  // hsync high for 96 counts                                                 
	assign VGA_vSync = (counter_y >= 0 && counter_y < 2) ? 1:0;   // vsync high for 2 counts

	always @ (posedge clk25MHz)
	begin
      if ((counter_y >= position_y && counter_y < position_y+size_y) ||
		     counter_y >= enemy_y_pos && counter_y < enemy_y_pos + enemy_size) // drawing an enemy
		
			// x section BEGIN
			begin
				if ((counter_x >= position_x && counter_x < position_x + size_x) ||
						counter_x >= enemy_x_pos && counter_x < position_x + enemy_size) // drawing an enemy
					begin
						r_red <= 4'hF;    
						r_blue <= 4'hF;
						r_green <= 4'hF;
					end 
				else 
					begin
						r_red <= 4'h0;    
						r_blue <= 4'h0;
						r_green <= 4'h0;
					end
			end
			// x section END
		else 
			begin
				r_red <= 4'h0;    
				r_blue <= 4'h0;
				r_green <= 4'h0;
			end		
	end
	
	always @ (posedge clk_move)
	begin
		if(direction_x == 1)
		begin
			position_x = position_x - 10;
		end
		else if(direction_x == 2)
		begin
			position_x = position_x + 10;
		end
		
		//
		if(position_x > 783 - size_x)
		begin
			position_x = 144;
		end
		else if(position_x < 144)
		begin
			position_x = 783 - size_x;
		end
		
		// enemy
		// enemy: move x
		if(enemy_direction == 0) begin
			enemy_x_pos = enemy_x_pos + 1;
			end
		else begin 
			enemy_x_pos = enemy_x_pos - 1;
			end
		// enemy: move down when chaneging a direction
		if(enemy_x_pos == 784 || enemy_x_pos == 144) begin
			enemy_direction = ~enemy_direction;
			enemy_y_pos = enemy_y_pos + 1;
			end
		
	end

	
	// color output assignments
	// only output the colors if the counters are within the adressable video time constraints
	assign Red = (counter_x > 144 && counter_x <= 783 && counter_y > 35 && counter_y <= 514) ? r_red : 4'h0;
	assign Blue = (counter_x > 144 && counter_x <= 783 && counter_y > 35 && counter_y <= 514) ? r_blue : 4'h0;
	assign Green = (counter_x > 144 && counter_x <= 783 && counter_y > 35 && counter_y <= 514) ? r_green : 4'h0;	
endmodule


module move_clk(clk, clk_move);
	input clk;
	output reg clk_move;
	reg [21:0] count;	

	always@(posedge clk)
	begin
		count <= count + 1;
		if(count == 1777777)
		begin
			clk_move <= ~clk_move;
			count <= 0;
		end	
	end
	
endmodule


module vga_clk(clk, clk25MHz);
	input clk; 					//50MHz clock
	output reg clk25MHz; 		//25MHz clock
	
	always@(posedge clk)
	begin
		clk25MHz=~clk25MHz;
	end
endmodule


module keyboard(kData, kClock, direction_x, LEDR);
	input kClock, kData;
	reg [10:0] key_code;
	reg [7:0] code;
	reg [7:0] prev_code;
	integer count = 0;
	output reg [2:0]  direction_x;
	output reg [9:0] LEDR;

	always@(negedge kClock) 
	begin
		key_code[count] = kData;
		count = count + 1;			
		if(count == 11)
		begin
			prev_code = code;
			code = key_code[8:1];
			LEDR = code;
			count = 0;
		end
	end
	
	always@(code)
	begin
		if(prev_code == 8'hF0) // break code
		begin
			direction_x = 0;
		end
		else if(code == 8'h1C) // a goes left
		begin
			direction_x = 1;
		end	
		else if(code == 8'h23) // d goes right
		begin
			direction_x = 2;
		end	

	end
endmodule
	
